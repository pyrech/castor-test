{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"01-installation/","text":"Installation and Autocomplete Installation [!NOTE] Castor requires PHP >= 8.1 to run. As a phar - recommended way You can download the latest release of Castor as a phar file from the releases page . You can also download the latest version by browsing the build page and selecting the last build. We provide different phar for Linux / MacOS / Windows architectures to offer lighter phar files. Download the correct one and make it available in your shell: Example for Linux: curl \"https://github.com/jolicode/castor/releases/latest/download/castor.linux-amd64.phar\" -Lfso $HOME/.local/bin/castor && \\ chmod u+x $HOME/.local/bin/castor && \\ castor --version || \\ (echo \"Could not install castor. Is the target directory writeable?\" && (exit 1)) Example for MacOS: curl \"https://github.com/jolicode/castor/releases/latest/download/castor.darwin-amd64.phar\" -Lfso /usr/local/bin/castor && \\ chmod u+x /usr/local/bin/castor && \\ castor --version || \\ (echo \"Could not install castor. Is the target directory writeable?\" && (exit 1)) Example for Windows: curl.exe \"https://github.com/jolicode/castor/releases/latest/download/castor.windows-amd64.phar\" -Lso C:\\<a directory in your PATH>\\castor Globally with Composer You can install Castor globally with Composer: composer global require jolicode/castor Then make sure that the Composer global bin directory is in your PATH . [!NOTE] The global Composer path may vary depending on your operating system. You can run the following command to determine it: composer config --list --global | grep -F \"[home]\" # It may looks like this on some Linux systems: # [home] /home/<your_username>/.config/composer # Or like this too: # [home] /home/<your_username>/.composer You can optionally replace /home/<your_username> with the Unix $HOME environment variable. Now, append /vendor/bin to that path to get the Composer global bin directory to add to your PATH : export PATH=\"$HOME/.config/composer/vendor/bin:$PATH\" Any binary globally installed with Composer will now work everywhere. Manually You'll need to clone the repository and run composer install to install the project. Then create a symlink to the castor file in your PATH . cd $HOME/somewhere git clone git@github.com:jolicode/castor.git cd castor composer install ln -s $PWD/bin/castor $HOME/.local/bin/castor With Docker If you don't have PHP >= 8.1 installed on your host, you can use Docker to run castor. However, some features like notifications will not work. We ship a Dockerfile that you can use to build a Docker image with castor: docker build -t castor . Then you can run castor with: docker run -it --rm -v `pwd`:/project castor If you want to use Docker commands in your tasks, you must enable Docker support when building the image: docker build -t castor --build-arg WITH_DOCKER=1 . Then you can run castor with: docker run -it --rm -v `pwd`:/project -v \"/var/run/docker.sock:/var/run/docker.sock:rw\" castor We suggest you to create an alias for it: alias castor='docker run -it --rm -v `pwd`:/project -v \"/var/run/docker.sock:/var/run/docker.sock:rw\" castor' In a Github Action Castor can also be installed in a Github Action by using the action shivammathur/setup-php@v2 and specifying castor in the tools option. This will configure PHP with the right version but also make castor available in the next steps. Here is an example: jobs: my-job: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: '8.1' tools: castor - name: Run castor \"hello\" task run: castor hello Autocomplete If you use bash, you can enable autocomplete for castor by running the following task: castor completion | sudo tee /etc/bash_completion.d/castor Then reload your shell. Others shells are also supported (zsh, fish, etc). To get the list of supported shells and their dedicated instructions, run: castor completion --help Stubs The first time you run castor, it will create a .castor.stub.php at the root directory of your project (where your castor.php is). This file contains some definition of classes and methods from Castor and some of its dependencies. This is useful when you install Castor from a PHAR, from a global composer install, etc. Without it, your IDE would complain that it does not understand some classes and would not provide any autocompletion in your castor files. We suggest you to add this file to your .gitignore to not version it in git. Castor will automatically update this file the first time you run Castor after you install or update it.","title":"Installation"},{"location":"01-installation/#installation-and-autocomplete","text":"","title":"Installation and Autocomplete"},{"location":"01-installation/#installation","text":"[!NOTE] Castor requires PHP >= 8.1 to run.","title":"Installation"},{"location":"01-installation/#as-a-phar-recommended-way","text":"You can download the latest release of Castor as a phar file from the releases page . You can also download the latest version by browsing the build page and selecting the last build. We provide different phar for Linux / MacOS / Windows architectures to offer lighter phar files. Download the correct one and make it available in your shell: Example for Linux: curl \"https://github.com/jolicode/castor/releases/latest/download/castor.linux-amd64.phar\" -Lfso $HOME/.local/bin/castor && \\ chmod u+x $HOME/.local/bin/castor && \\ castor --version || \\ (echo \"Could not install castor. Is the target directory writeable?\" && (exit 1)) Example for MacOS: curl \"https://github.com/jolicode/castor/releases/latest/download/castor.darwin-amd64.phar\" -Lfso /usr/local/bin/castor && \\ chmod u+x /usr/local/bin/castor && \\ castor --version || \\ (echo \"Could not install castor. Is the target directory writeable?\" && (exit 1)) Example for Windows: curl.exe \"https://github.com/jolicode/castor/releases/latest/download/castor.windows-amd64.phar\" -Lso C:\\<a directory in your PATH>\\castor","title":"As a phar - recommended way"},{"location":"01-installation/#globally-with-composer","text":"You can install Castor globally with Composer: composer global require jolicode/castor Then make sure that the Composer global bin directory is in your PATH . [!NOTE] The global Composer path may vary depending on your operating system. You can run the following command to determine it: composer config --list --global | grep -F \"[home]\" # It may looks like this on some Linux systems: # [home] /home/<your_username>/.config/composer # Or like this too: # [home] /home/<your_username>/.composer You can optionally replace /home/<your_username> with the Unix $HOME environment variable. Now, append /vendor/bin to that path to get the Composer global bin directory to add to your PATH : export PATH=\"$HOME/.config/composer/vendor/bin:$PATH\" Any binary globally installed with Composer will now work everywhere.","title":"Globally with Composer"},{"location":"01-installation/#manually","text":"You'll need to clone the repository and run composer install to install the project. Then create a symlink to the castor file in your PATH . cd $HOME/somewhere git clone git@github.com:jolicode/castor.git cd castor composer install ln -s $PWD/bin/castor $HOME/.local/bin/castor","title":"Manually"},{"location":"01-installation/#with-docker","text":"If you don't have PHP >= 8.1 installed on your host, you can use Docker to run castor. However, some features like notifications will not work. We ship a Dockerfile that you can use to build a Docker image with castor: docker build -t castor . Then you can run castor with: docker run -it --rm -v `pwd`:/project castor If you want to use Docker commands in your tasks, you must enable Docker support when building the image: docker build -t castor --build-arg WITH_DOCKER=1 . Then you can run castor with: docker run -it --rm -v `pwd`:/project -v \"/var/run/docker.sock:/var/run/docker.sock:rw\" castor We suggest you to create an alias for it: alias castor='docker run -it --rm -v `pwd`:/project -v \"/var/run/docker.sock:/var/run/docker.sock:rw\" castor'","title":"With Docker"},{"location":"01-installation/#in-a-github-action","text":"Castor can also be installed in a Github Action by using the action shivammathur/setup-php@v2 and specifying castor in the tools option. This will configure PHP with the right version but also make castor available in the next steps. Here is an example: jobs: my-job: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Setup PHP uses: shivammathur/setup-php@v2 with: php-version: '8.1' tools: castor - name: Run castor \"hello\" task run: castor hello","title":"In a Github Action"},{"location":"01-installation/#autocomplete","text":"If you use bash, you can enable autocomplete for castor by running the following task: castor completion | sudo tee /etc/bash_completion.d/castor Then reload your shell. Others shells are also supported (zsh, fish, etc). To get the list of supported shells and their dedicated instructions, run: castor completion --help","title":"Autocomplete"},{"location":"01-installation/#stubs","text":"The first time you run castor, it will create a .castor.stub.php at the root directory of your project (where your castor.php is). This file contains some definition of classes and methods from Castor and some of its dependencies. This is useful when you install Castor from a PHAR, from a global composer install, etc. Without it, your IDE would complain that it does not understand some classes and would not provide any autocompletion in your castor files. We suggest you to add this file to your .gitignore to not version it in git. Castor will automatically update this file the first time you run Castor after you install or update it.","title":"Stubs"},{"location":"02-basic-usage/","text":"Basic usage Castor use a convention to find tasks. It will look for the first castor.php file in the current directory or in parents directory. In this file, all functions with the Castor\\Attribute\\AsTask attribute will be transformed as tasks. The name of the function will be the task's name and the namespace will be the task's namespace. For example, if you have the following file: <?php namespace hello; use Castor\\Attribute\\AsTask; #[AsTask()] function castor(): void { echo 'Hello castor'; } namespace foo; use Castor\\Attribute\\AsTask; #[AsTask()] function bar(): void { echo 'Foo bar'; } You will have two tasks: hello:castor and foo:bar . If there is no namespace then the task will have no namespace. From now on, we will omit the leading <?php in all doc examples. [!TIP] Related example: foo.php Splitting tasks in multiple files Using a directory Castor will also look for castor directory in the same directory of the castor.php file and load all the PHP files from it. You could then have an empty castor.php file and split your tasks in multiple files, like castor/hello.php and castor/foo.php . The import() function You can also use the import() function to import tasks from another file. This function takes a file path, or a directory as an argument. When using a directory as an argument, Castor will load all the PHP files in it: use function Castor\\import; import(__DIR__ . '/custom-commands.php'); import(__DIR__ . '/my-app/castor'); [!WARNING] You cannot dynamically import tasks. The import() function must be called at the top level of the file. Overriding task name, namespace or description The Castor\\Attribute\\AsTask attribute takes three optional arguments: name , namespace and description to override the default values: use Castor\\Attribute\\AsTask; #[AsTask(name: 'bar', namespace: 'foo', description: 'Echo foo bar')] function a_very_long_function_name_that_is_very_painful_to_write(): void { echo 'Foo bar'; } [!TIP] Related example: foo.php","title":"Basic usage"},{"location":"02-basic-usage/#basic-usage","text":"Castor use a convention to find tasks. It will look for the first castor.php file in the current directory or in parents directory. In this file, all functions with the Castor\\Attribute\\AsTask attribute will be transformed as tasks. The name of the function will be the task's name and the namespace will be the task's namespace. For example, if you have the following file: <?php namespace hello; use Castor\\Attribute\\AsTask; #[AsTask()] function castor(): void { echo 'Hello castor'; } namespace foo; use Castor\\Attribute\\AsTask; #[AsTask()] function bar(): void { echo 'Foo bar'; } You will have two tasks: hello:castor and foo:bar . If there is no namespace then the task will have no namespace. From now on, we will omit the leading <?php in all doc examples. [!TIP] Related example: foo.php","title":"Basic usage"},{"location":"02-basic-usage/#splitting-tasks-in-multiple-files","text":"","title":"Splitting tasks in multiple files"},{"location":"02-basic-usage/#using-a-directory","text":"Castor will also look for castor directory in the same directory of the castor.php file and load all the PHP files from it. You could then have an empty castor.php file and split your tasks in multiple files, like castor/hello.php and castor/foo.php .","title":"Using a directory"},{"location":"02-basic-usage/#the-import-function","text":"You can also use the import() function to import tasks from another file. This function takes a file path, or a directory as an argument. When using a directory as an argument, Castor will load all the PHP files in it: use function Castor\\import; import(__DIR__ . '/custom-commands.php'); import(__DIR__ . '/my-app/castor'); [!WARNING] You cannot dynamically import tasks. The import() function must be called at the top level of the file.","title":"The import() function"},{"location":"02-basic-usage/#overriding-task-name-namespace-or-description","text":"The Castor\\Attribute\\AsTask attribute takes three optional arguments: name , namespace and description to override the default values: use Castor\\Attribute\\AsTask; #[AsTask(name: 'bar', namespace: 'foo', description: 'Echo foo bar')] function a_very_long_function_name_that_is_very_painful_to_write(): void { echo 'Foo bar'; } [!TIP] Related example: foo.php","title":"Overriding task name, namespace or description"},{"location":"03-run/","text":"Executing Processes The run() function Castor provides a run() function to execute external processes. use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"'); run(['echo', 'bar']); } You can pass a string or an array of string for this function. When passing a string, arguments will not be escaped - use it carefully. Process object Under the hood, Castor uses the Symfony\\Component\\Process\\Process object to execute the process. The run() function will return this object. So you can use the API of this class to interact with the underlying process: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { $process = run('echo \"bar\"'); $process->isSuccessful(); // will return true } [!TIP] Related example: run.php Failure By default, Castor will throw an exception if the process fails. You can disable that by setting the allowFailure option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('a_command_that_does_not_exist', allowFailure: true); } [!TIP] Related example: failure.php Working directory By default, Castor will execute the process in the same directory as the castor.php file. You can change that by setting the path argument. It can be either a relative or an absolute path: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('pwd', path: '../'); // run the process in the parent directory of the castor.php file run('pwd', path: '/tmp'); // run the process in the /tmp directory } [!TIP] Related example: cd.php Environment variables By default, Castor will use the same environment variables as the current process. You can add or override environment variables by setting the environment argument: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo $FOO', environment: ['FOO' => 'bar']); // will print \"bar\" } [!TIP] Related example: env.php Processing the output By default, Castor will forward the stdout and stderr to the current terminal. If you do not want to print the process output you can set the quiet option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', quiet: true); // will not print anything } You can also fetch the process output by using the returned Symfony\\Component\\Process\\Process object: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { $process = run('echo \"bar\"', quiet: true); // will not print anything $output = $process->getOutput(); // will return \"bar\\n\" } [!TIP] Related example: quiet.php The capture() function Castor provides a capture() function that will run the process quietly, trims the output, then returns it: use Castor\\Attribute\\AsTask; use function Castor\\capture; #[AsTask()] function whoami() { $whoami = capture('whoami'); echo \"Hello: $whoami\\n\"; } [!TIP] Related example: run.php The exit_code() function Castor provides a exit_code() function that will run the command, allowing the process to fail and return its exit code. This is particularly useful when running tasks on CI as this allows the CI to know if the task failed or not: use Castor\\Attribute\\AsTask; use function Castor\\exit_code; #[AsTask()] function cs(): int { return exit_code('php-cs-fixer fix --dry-run'); } [!TIP] Related example: run.php Timeout By default, Castor will use a 60 seconds timeout on all your run() calls. If you want to tweak that you need to set the timeout argument. use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', timeout: 120); } This process will have a 2 minutes timeout. If you want to disable that feature, you need to set the timeout to 0 . use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', timeout: 0); } [!TIP] Related example: wait_for.php PTY & TTY By default, Castor will use a pseudo terminal (PTY) to run the underlying process, which allows to have nice output in most cases. For some commands you may want to disable the PTY and use a TTY instead. You can do that by setting the tty option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', tty: true); } [!WARNING] When using a TTY, the output of the command is empty in the process object (when using getOutput() or getErrorOutput() ). You can also disable the pty by setting the pty option to false . If pty and tty are both set to false , the standard input will not be forwarded to the process: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', pty: false); }","title":"Executing Processes"},{"location":"03-run/#executing-processes","text":"","title":"Executing Processes"},{"location":"03-run/#the-run-function","text":"Castor provides a run() function to execute external processes. use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"'); run(['echo', 'bar']); } You can pass a string or an array of string for this function. When passing a string, arguments will not be escaped - use it carefully.","title":"The run() function"},{"location":"03-run/#process-object","text":"Under the hood, Castor uses the Symfony\\Component\\Process\\Process object to execute the process. The run() function will return this object. So you can use the API of this class to interact with the underlying process: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { $process = run('echo \"bar\"'); $process->isSuccessful(); // will return true } [!TIP] Related example: run.php","title":"Process object"},{"location":"03-run/#failure","text":"By default, Castor will throw an exception if the process fails. You can disable that by setting the allowFailure option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('a_command_that_does_not_exist', allowFailure: true); } [!TIP] Related example: failure.php","title":"Failure"},{"location":"03-run/#working-directory","text":"By default, Castor will execute the process in the same directory as the castor.php file. You can change that by setting the path argument. It can be either a relative or an absolute path: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('pwd', path: '../'); // run the process in the parent directory of the castor.php file run('pwd', path: '/tmp'); // run the process in the /tmp directory } [!TIP] Related example: cd.php","title":"Working directory"},{"location":"03-run/#environment-variables","text":"By default, Castor will use the same environment variables as the current process. You can add or override environment variables by setting the environment argument: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo $FOO', environment: ['FOO' => 'bar']); // will print \"bar\" } [!TIP] Related example: env.php","title":"Environment variables"},{"location":"03-run/#processing-the-output","text":"By default, Castor will forward the stdout and stderr to the current terminal. If you do not want to print the process output you can set the quiet option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', quiet: true); // will not print anything } You can also fetch the process output by using the returned Symfony\\Component\\Process\\Process object: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { $process = run('echo \"bar\"', quiet: true); // will not print anything $output = $process->getOutput(); // will return \"bar\\n\" } [!TIP] Related example: quiet.php","title":"Processing the output"},{"location":"03-run/#the-capture-function","text":"Castor provides a capture() function that will run the process quietly, trims the output, then returns it: use Castor\\Attribute\\AsTask; use function Castor\\capture; #[AsTask()] function whoami() { $whoami = capture('whoami'); echo \"Hello: $whoami\\n\"; } [!TIP] Related example: run.php","title":"The capture() function"},{"location":"03-run/#the-exit_code-function","text":"Castor provides a exit_code() function that will run the command, allowing the process to fail and return its exit code. This is particularly useful when running tasks on CI as this allows the CI to know if the task failed or not: use Castor\\Attribute\\AsTask; use function Castor\\exit_code; #[AsTask()] function cs(): int { return exit_code('php-cs-fixer fix --dry-run'); } [!TIP] Related example: run.php","title":"The exit_code() function"},{"location":"03-run/#timeout","text":"By default, Castor will use a 60 seconds timeout on all your run() calls. If you want to tweak that you need to set the timeout argument. use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', timeout: 120); } This process will have a 2 minutes timeout. If you want to disable that feature, you need to set the timeout to 0 . use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', timeout: 0); } [!TIP] Related example: wait_for.php","title":"Timeout"},{"location":"03-run/#pty-tty","text":"By default, Castor will use a pseudo terminal (PTY) to run the underlying process, which allows to have nice output in most cases. For some commands you may want to disable the PTY and use a TTY instead. You can do that by setting the tty option to true : use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', tty: true); } [!WARNING] When using a TTY, the output of the command is empty in the process object (when using getOutput() or getErrorOutput() ). You can also disable the pty by setting the pty option to false . If pty and tty are both set to false , the standard input will not be forwarded to the process: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function foo(): void { run('echo \"bar\"', pty: false); }","title":"PTY &amp; TTY"},{"location":"04-arguments/","text":"Task arguments When creating a function that will be used as a task, all the parameters of the function will be used as arguments or options: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function task( string $firstArg, string $secondArg ) { run(['echo', $firstArg, $secondArg]); } Which can be called like that: $ castor task foo bar foo bar Optional arguments You can make an argument optional by giving it a default value: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function task( string $firstArg, string $default = 'default' ) { run(['echo', $firstArg, $secondArg]); } $ castor task foo foo default $ castor task --default=bar foo foo bar [!TIP] Related example: args.php Overriding the argument name and description You can override the name and description of an argument by using the Castor\\Attribute\\AsArgument attribute: use Castor\\Attribute\\AsArgument; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsArgument(name: 'foo', description: 'This is the foo argument')] string $arg = 'bar', ) { run(['echo', $arg]); } $ castor command foo foo [!TIP] Related example: args.php Overriding the option name and description If you prefer, you can force an argument to be an option by using the Castor\\Attribute\\AsOption attribute: use Castor\\Attribute\\AsOption; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsOption(name: 'foo', description: 'This is the foo option')] string $arg = 'bar', ) { run(['echo', $arg]); } $ castor command --foo=foo foo You can also configure the mode of the option. The mode determines how the option must be configured: use Castor\\Attribute\\AsOption; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsOption(description: 'This is the foo option', mode: InputOption::VALUE_NONE)] bool $force, ) { if ($force) { echo \"command has been forced\\n\"; } } $ castor command --force command has been forced [!TIP] Related example: args.php Please refer to the Symfony documentation for more information.","title":"Task arguments"},{"location":"04-arguments/#task-arguments","text":"When creating a function that will be used as a task, all the parameters of the function will be used as arguments or options: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function task( string $firstArg, string $secondArg ) { run(['echo', $firstArg, $secondArg]); } Which can be called like that: $ castor task foo bar foo bar","title":"Task arguments"},{"location":"04-arguments/#optional-arguments","text":"You can make an argument optional by giving it a default value: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function task( string $firstArg, string $default = 'default' ) { run(['echo', $firstArg, $secondArg]); } $ castor task foo foo default $ castor task --default=bar foo foo bar [!TIP] Related example: args.php","title":"Optional arguments"},{"location":"04-arguments/#overriding-the-argument-name-and-description","text":"You can override the name and description of an argument by using the Castor\\Attribute\\AsArgument attribute: use Castor\\Attribute\\AsArgument; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsArgument(name: 'foo', description: 'This is the foo argument')] string $arg = 'bar', ) { run(['echo', $arg]); } $ castor command foo foo [!TIP] Related example: args.php","title":"Overriding the argument name and description"},{"location":"04-arguments/#overriding-the-option-name-and-description","text":"If you prefer, you can force an argument to be an option by using the Castor\\Attribute\\AsOption attribute: use Castor\\Attribute\\AsOption; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsOption(name: 'foo', description: 'This is the foo option')] string $arg = 'bar', ) { run(['echo', $arg]); } $ castor command --foo=foo foo You can also configure the mode of the option. The mode determines how the option must be configured: use Castor\\Attribute\\AsOption; use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function command( #[AsOption(description: 'This is the foo option', mode: InputOption::VALUE_NONE)] bool $force, ) { if ($force) { echo \"command has been forced\\n\"; } } $ castor command --force command has been forced [!TIP] Related example: args.php Please refer to the Symfony documentation for more information.","title":"Overriding the option name and description"},{"location":"05-context/","text":"Context For every task that Castor run, it uses a Context object. This object contains the default values for the run or watch function (directory, environment variables, pty, tty, etc...). It also contains custom values that can be set by the user and reused in tasks. The context is immutable, which means that every time you change a value, a new context is created. Using the context The context() function You can get the initial context thanks to the context() function: use Castor\\Attribute\\AsTask; use function Castor\\context; use function Castor\\run; #[AsTask()] function foo(): void { $context = context(); echo $context->currentDirectory; // will print the directory of the castor.php file $context = $context->withPath('/tmp'); // will create a new context where the current directory is /tmp run('pwd', context: $context); // will print \"/tmp\" } [!TIP] Related example: context.php The variable() function Castor also provides a variable() function to get the value of a variable stored in the Context : use Castor\\Attribute\\AsTask; use function Castor\\context; use function Castor\\variable; #[AsTask()] function foo(): void { $foobar = variable('foobar', 'default value'); // Same as: $context = context(); try { $foobar = $context['foobar']; } catch (\\OutOfBoundsException) { $foobar = 'default value; } } [!TIP] Related example: context.php Creating a new context You can create a new context by declaring a function with the Castor\\Attribute\\AsContext attribute: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext()] function my_context(): Context { return new Context(environment: ['FOO' => 'BAR']); } #[AsTask()] function foo(): void { run('echo $FOO'); } By default the foo task will not print anything as the FOO environment variable is not set. If you want to use your new context you can use the --context option: $ php castor.phar foo $ php castor.phar foo --context=my-context BAR [!NOTE] You can override the context name by setting the name argument of the AsContext attribute. [!TIP] Related example: context.php Setting a default context You may want to set a default context for all your tasks. You can do that by setting the default argument to true in the AsContext attribute: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext(default: true, name: 'my_context')] function create_default_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(Context $context): void { run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd'); // will print /tmp } Advanced usage See this documentation for more usage about contexts.","title":"Context"},{"location":"05-context/#context","text":"For every task that Castor run, it uses a Context object. This object contains the default values for the run or watch function (directory, environment variables, pty, tty, etc...). It also contains custom values that can be set by the user and reused in tasks. The context is immutable, which means that every time you change a value, a new context is created.","title":"Context"},{"location":"05-context/#using-the-context","text":"","title":"Using the context"},{"location":"05-context/#the-context-function","text":"You can get the initial context thanks to the context() function: use Castor\\Attribute\\AsTask; use function Castor\\context; use function Castor\\run; #[AsTask()] function foo(): void { $context = context(); echo $context->currentDirectory; // will print the directory of the castor.php file $context = $context->withPath('/tmp'); // will create a new context where the current directory is /tmp run('pwd', context: $context); // will print \"/tmp\" } [!TIP] Related example: context.php","title":"The context() function"},{"location":"05-context/#the-variable-function","text":"Castor also provides a variable() function to get the value of a variable stored in the Context : use Castor\\Attribute\\AsTask; use function Castor\\context; use function Castor\\variable; #[AsTask()] function foo(): void { $foobar = variable('foobar', 'default value'); // Same as: $context = context(); try { $foobar = $context['foobar']; } catch (\\OutOfBoundsException) { $foobar = 'default value; } } [!TIP] Related example: context.php","title":"The variable() function"},{"location":"05-context/#creating-a-new-context","text":"You can create a new context by declaring a function with the Castor\\Attribute\\AsContext attribute: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext()] function my_context(): Context { return new Context(environment: ['FOO' => 'BAR']); } #[AsTask()] function foo(): void { run('echo $FOO'); } By default the foo task will not print anything as the FOO environment variable is not set. If you want to use your new context you can use the --context option: $ php castor.phar foo $ php castor.phar foo --context=my-context BAR [!NOTE] You can override the context name by setting the name argument of the AsContext attribute. [!TIP] Related example: context.php","title":"Creating a new context"},{"location":"05-context/#setting-a-default-context","text":"You may want to set a default context for all your tasks. You can do that by setting the default argument to true in the AsContext attribute: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext(default: true, name: 'my_context')] function create_default_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(Context $context): void { run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd'); // will print /tmp }","title":"Setting a default context"},{"location":"05-context/#advanced-usage","text":"See this documentation for more usage about contexts.","title":"Advanced usage"},{"location":"06-reference/","text":"Castor reference Here is a reference of all the functions and attributes provided by Castor. Functions Castor provides the following built-in functions: add_context app cache capture context exit_code finder fingerprint fingerprint_exists fingerprint_save fs get_cache guard_min_version hasher http_client import input io load_dot_env log logger notify output parallel request task run ssh_download ssh_run ssh_upload variable wait_for wait_for_url wait_for_http_response wait_for_http_status wait_for_port wait_for_docker_container watch with Attributes Castor provides the following attributes to register tasks, listener, etc: AsArgument AsContext AsListener AsOption AsSymfonyTask AsTask","title":"Castor reference"},{"location":"06-reference/#castor-reference","text":"Here is a reference of all the functions and attributes provided by Castor.","title":"Castor reference"},{"location":"06-reference/#functions","text":"Castor provides the following built-in functions: add_context app cache capture context exit_code finder fingerprint fingerprint_exists fingerprint_save fs get_cache guard_min_version hasher http_client import input io load_dot_env log logger notify output parallel request task run ssh_download ssh_run ssh_upload variable wait_for wait_for_url wait_for_http_response wait_for_http_status wait_for_port wait_for_docker_container watch with","title":"Functions"},{"location":"06-reference/#attributes","text":"Castor provides the following attributes to register tasks, listener, etc: AsArgument AsContext AsListener AsOption AsSymfonyTask AsTask","title":"Attributes"},{"location":"going-further/","text":"Going further with Castor Helpers Manipulating the input and output and interacting with the Console Filesystem HTTP requests Cache Notification Parallel execution Watching files changes SSH and remote servers Waiting for things Fingerprinting and code execution when something changes Guard to check the version of castor Re-use Symfony Command Interacting with Castor Log and Debug Handling signals Using .env files Extending Castor Listening to events Repacking your application in a new phar Compiling your application in a standalone binary Examples This project provides a bunch of usage examples in the examples directory . These examples are useful to show different Castor features in action, do not hesitate to browse them. They also act as a full test suite for Castor to ensure each feature works as expected.","title":"Going further with Castor"},{"location":"going-further/#going-further-with-castor","text":"","title":"Going further with Castor"},{"location":"going-further/#helpers","text":"Manipulating the input and output and interacting with the Console Filesystem HTTP requests Cache Notification Parallel execution Watching files changes SSH and remote servers Waiting for things Fingerprinting and code execution when something changes Guard to check the version of castor Re-use Symfony Command","title":"Helpers"},{"location":"going-further/#interacting-with-castor","text":"Log and Debug Handling signals Using .env files","title":"Interacting with Castor"},{"location":"going-further/#extending-castor","text":"Listening to events Repacking your application in a new phar Compiling your application in a standalone binary","title":"Extending Castor"},{"location":"going-further/#examples","text":"This project provides a bunch of usage examples in the examples directory . These examples are useful to show different Castor features in action, do not hesitate to browse them. They also act as a full test suite for Castor to ensure each feature works as expected.","title":"Examples"},{"location":"going-further/advanced-context/","text":"Advanced Context usage Disabled tasks according to the context You can disable a task according to the context by using the AsTask::enabled argument: use Castor\\Attribute\\AsTask; #[AsTask(description: 'Say hello, but only in production', enabled: \"var('production') == true\")] function hello(): void { echo \"Hello world!\\n\"; } The value can be one of: true : always enabled (default value) false : always disabled a string: it represents an expression that will be evaluated in the context of the task and must return a bool . The task will be enabled if the expression returns true and disabled otherwise. The expression can use the var() function to get the value of a variable. Internally, it uses the symfony/expression-language component. Getting a specific context You can get a specific context by its name using the context() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext(name: 'my_context')] function create_my_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(): void { $context = context('my_context'); run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd', context: $context); // will print /tmp } The with() function You may want to run a bunch of commands inside a specific directory or with a specific context. Instead of passing those parameters to each run, you can use the with() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; use function Castor\\with; #[AsContext(name: 'my_context')] function create_my_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(): void { with(function (Context $context) { run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd'); // will print /tmp }, context: 'my_context'); } The add_context() function In some case, you may want to programmatically define contexts. You can use the add_context() to do so: use Castor\\Context; use function Castor\\add_context; add_context('dynamic', fn () => new Context([ 'name' => 'dynamic', 'production' => false, 'foo' => 'baz', ])); [!NOTE] You should use the add_context() function at the top level of your Castor files (not in a task function), in order to make these contexts available to all tasks.","title":"Advanced Context usage"},{"location":"going-further/advanced-context/#advanced-context-usage","text":"","title":"Advanced Context usage"},{"location":"going-further/advanced-context/#disabled-tasks-according-to-the-context","text":"You can disable a task according to the context by using the AsTask::enabled argument: use Castor\\Attribute\\AsTask; #[AsTask(description: 'Say hello, but only in production', enabled: \"var('production') == true\")] function hello(): void { echo \"Hello world!\\n\"; } The value can be one of: true : always enabled (default value) false : always disabled a string: it represents an expression that will be evaluated in the context of the task and must return a bool . The task will be enabled if the expression returns true and disabled otherwise. The expression can use the var() function to get the value of a variable. Internally, it uses the symfony/expression-language component.","title":"Disabled tasks according to the context"},{"location":"going-further/advanced-context/#getting-a-specific-context","text":"You can get a specific context by its name using the context() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; #[AsContext(name: 'my_context')] function create_my_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(): void { $context = context('my_context'); run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd', context: $context); // will print /tmp }","title":"Getting a specific context"},{"location":"going-further/advanced-context/#the-with-function","text":"You may want to run a bunch of commands inside a specific directory or with a specific context. Instead of passing those parameters to each run, you can use the with() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\run; use function Castor\\with; #[AsContext(name: 'my_context')] function create_my_context(): Context { return new Context(['foo' => 'bar'], currentDirectory: '/tmp'); } #[AsTask()] function foo(): void { with(function (Context $context) { run(['echo', $context['foo']]); // will print bar even if you do not use the --context option run('pwd'); // will print /tmp }, context: 'my_context'); }","title":"The with() function"},{"location":"going-further/advanced-context/#the-add_context-function","text":"In some case, you may want to programmatically define contexts. You can use the add_context() to do so: use Castor\\Context; use function Castor\\add_context; add_context('dynamic', fn () => new Context([ 'name' => 'dynamic', 'production' => false, 'foo' => 'baz', ])); [!NOTE] You should use the add_context() function at the top level of your Castor files (not in a task function), in order to make these contexts available to all tasks.","title":"The add_context() function"},{"location":"going-further/cache/","text":"Cache The cache() function Castor provides a cache() function to allow to cache items easily: use Castor\\Attribute\\AsTask; use Psr\\Cache\\CacheItemInterface; use function Castor\\cache; #[AsTask()] function foo() { echo cache('a-key', expansive_call(...)); // Or if you want to set a TTL echo cache('another-key', function (CacheItemInterface $item) => { $item->expiresAfter(3600); return expansive_call(); }); } By default, it caches items on the filesystem, in the <home directory>/.cache/castor directory. The function also prefix the key with a hash of the project directory to avoid any collision between different Castor projects. [!NOTE] Under the hood, Castor use Symfony Cache component. You can check the Symfony documentation for more information about this component and how to use it. The get_cache() function If you need to have a full control on the cache, you can access the CacheItemPollInterface directly with the get_cache() function: use Castor\\Attribute\\AsTask; use function Castor\\get_cache; #[AsTask()] function foo() { $cache = get_cache(); $item = $cache->getItem('a-key'); if (!$item->isHit()) { $item->set(expansive_call()); $cache->save($item); } echo $item->get(); }","title":"Cache"},{"location":"going-further/cache/#cache","text":"","title":"Cache"},{"location":"going-further/cache/#the-cache-function","text":"Castor provides a cache() function to allow to cache items easily: use Castor\\Attribute\\AsTask; use Psr\\Cache\\CacheItemInterface; use function Castor\\cache; #[AsTask()] function foo() { echo cache('a-key', expansive_call(...)); // Or if you want to set a TTL echo cache('another-key', function (CacheItemInterface $item) => { $item->expiresAfter(3600); return expansive_call(); }); } By default, it caches items on the filesystem, in the <home directory>/.cache/castor directory. The function also prefix the key with a hash of the project directory to avoid any collision between different Castor projects. [!NOTE] Under the hood, Castor use Symfony Cache component. You can check the Symfony documentation for more information about this component and how to use it.","title":"The cache() function"},{"location":"going-further/cache/#the-get_cache-function","text":"If you need to have a full control on the cache, you can access the CacheItemPollInterface directly with the get_cache() function: use Castor\\Attribute\\AsTask; use function Castor\\get_cache; #[AsTask()] function foo() { $cache = get_cache(); $item = $cache->getItem('a-key'); if (!$item->isHit()) { $item->set(expansive_call()); $cache->save($item); } echo $item->get(); }","title":"The get_cache() function"},{"location":"going-further/compile/","text":"Compiling your application into a standalone binary Packing your Castor application as a phar can be a good way to easily share and use it in various environments. However, you need to ensure that PHP is installed and configured correctly in all the environments where you want to use your Castor app. This can be a hassle, especially if you don't have control over the environments. To make things simpler, Castor's compile command can help by creating a customizable PHP binary with a phar, making one executable file that can be used in any setting. Just pass your repacked Castor app phar as an argument of this command. Pre-requisites Follow the repack documentation to produce a phar of your Castor app. Running the Compile Command To compile your Castor application, navigate to your project directory and run: vendor/bin/castor compile my-custom-castor-app.phar [!WARNING] Compiling is not supported yet on Windows. Options Make sure to take a look at the command description to see all the available options: vendor/bin/castor compile --help Behavior The compile command performs several steps: Downloads or uses an existing Static PHP CLI tool to compile PHP and the phar into a binary. If required, it automatically installs dependencies and compiles PHP with the specified extensions. Combines the compiled PHP and your phar file into a single executable. Post-Compilation Once the compilation is finished, your Castor application is transformed into a standalone binary named castor by default (you can use the --output option to change it). This binary is now ready to be distributed and run in environments that do not have PHP installed. You can simply run it like any other executable: ./castor","title":"Compiling your application into a standalone binary"},{"location":"going-further/compile/#compiling-your-application-into-a-standalone-binary","text":"Packing your Castor application as a phar can be a good way to easily share and use it in various environments. However, you need to ensure that PHP is installed and configured correctly in all the environments where you want to use your Castor app. This can be a hassle, especially if you don't have control over the environments. To make things simpler, Castor's compile command can help by creating a customizable PHP binary with a phar, making one executable file that can be used in any setting. Just pass your repacked Castor app phar as an argument of this command.","title":"Compiling your application into a standalone binary"},{"location":"going-further/compile/#pre-requisites","text":"Follow the repack documentation to produce a phar of your Castor app.","title":"Pre-requisites"},{"location":"going-further/compile/#running-the-compile-command","text":"To compile your Castor application, navigate to your project directory and run: vendor/bin/castor compile my-custom-castor-app.phar [!WARNING] Compiling is not supported yet on Windows.","title":"Running the Compile Command"},{"location":"going-further/compile/#options","text":"Make sure to take a look at the command description to see all the available options: vendor/bin/castor compile --help","title":"Options"},{"location":"going-further/compile/#behavior","text":"The compile command performs several steps: Downloads or uses an existing Static PHP CLI tool to compile PHP and the phar into a binary. If required, it automatically installs dependencies and compiles PHP with the specified extensions. Combines the compiled PHP and your phar file into a single executable.","title":"Behavior"},{"location":"going-further/compile/#post-compilation","text":"Once the compilation is finished, your Castor application is transformed into a standalone binary named castor by default (you can use the --output option to change it). This binary is now ready to be distributed and run in environments that do not have PHP installed. You can simply run it like any other executable: ./castor","title":"Post-Compilation"},{"location":"going-further/console-and-io/","text":"Manipulating the input and output and interacting with the Console Castor is heavily based on Symfony's Console component . This means that some powers of this component are available to you. The io() function The io() returns an object that provides methods to interact with the user and to display information. It returns an instance of Symfony\\Component\\Console\\Style\\SymfonyStyle : use Castor\\Attribute\\AsTask; use function Castor\\io; #[AsTask()] function foo(): void { io()->title('This is a title'); io()->comment('With IO, you can ask questions ...'); $value = io()->ask('Tell me something'); io()->writeln('You said: ' . $value); io()->comment('... show progress bars ...'); io()->progressStart(100); for ($i = 0; $i < 100; ++$i) { io()->progressAdvance(); usleep(1000); } io()->progressFinish(); io()->comment('... show table ...'); io()->table(['Name', 'Age'], [ ['Alice', 21], ['Bob', 42], ]); io()->success('This is a success message'); } [!NOTE] You can check the Symfony documentation for more information about this class and how to use it. The input() function Castor provides the input() to access the current [ Input ](https://github.com/symfony/symfony/blob/6.3/src/Symfony/Component/Console/Input/InputInterface.php object. The output() function Castor provides the output() to access the current Output object. The app() function Castor provides the app() to access the current Application object. The task() function Castor provides the task() to access the current Symfony Command object that powers the task currently run by the user. [!NOTE] The task() will reference the Castor task ran by the user, not the one where task() may be called. Considering the example below: #[AsTask()] function foo(): void { io()->title(task()->getName()); } #[AsTask()] function bar(): void { foo(); } castor bar will output bar , not foo , even if this is the foo() function that triggers the call to task() .","title":"Manipulating the input and output and interacting with the Console"},{"location":"going-further/console-and-io/#manipulating-the-input-and-output-and-interacting-with-the-console","text":"Castor is heavily based on Symfony's Console component . This means that some powers of this component are available to you.","title":"Manipulating the input and output and interacting with the Console"},{"location":"going-further/console-and-io/#the-io-function","text":"The io() returns an object that provides methods to interact with the user and to display information. It returns an instance of Symfony\\Component\\Console\\Style\\SymfonyStyle : use Castor\\Attribute\\AsTask; use function Castor\\io; #[AsTask()] function foo(): void { io()->title('This is a title'); io()->comment('With IO, you can ask questions ...'); $value = io()->ask('Tell me something'); io()->writeln('You said: ' . $value); io()->comment('... show progress bars ...'); io()->progressStart(100); for ($i = 0; $i < 100; ++$i) { io()->progressAdvance(); usleep(1000); } io()->progressFinish(); io()->comment('... show table ...'); io()->table(['Name', 'Age'], [ ['Alice', 21], ['Bob', 42], ]); io()->success('This is a success message'); } [!NOTE] You can check the Symfony documentation for more information about this class and how to use it.","title":"The io() function"},{"location":"going-further/console-and-io/#the-input-function","text":"Castor provides the input() to access the current [ Input ](https://github.com/symfony/symfony/blob/6.3/src/Symfony/Component/Console/Input/InputInterface.php object.","title":"The input() function"},{"location":"going-further/console-and-io/#the-output-function","text":"Castor provides the output() to access the current Output object.","title":"The output() function"},{"location":"going-further/console-and-io/#the-app-function","text":"Castor provides the app() to access the current Application object.","title":"The app() function"},{"location":"going-further/console-and-io/#the-task-function","text":"Castor provides the task() to access the current Symfony Command object that powers the task currently run by the user. [!NOTE] The task() will reference the Castor task ran by the user, not the one where task() may be called. Considering the example below: #[AsTask()] function foo(): void { io()->title(task()->getName()); } #[AsTask()] function bar(): void { foo(); } castor bar will output bar , not foo , even if this is the foo() function that triggers the call to task() .","title":"The task() function"},{"location":"going-further/dot-env/","text":"Using .env files The load_dot_env() function You can load a .env file with the load_dot_env() function. This will: - load the .env file - populate the env variables for the current process - return the env variables as key/value array. [!NOTE] By default, it loads the .env file on your project root (where castor file or folder was found), but you can overload this by passing your .env file path as an argument. Example: use Castor\\Attribute\\AsTask; use Castor\\Context; use function Castor\\load_dot_env; #[AsTask()] function show_database_url(): void { $env = load_dot_env(); echo $env['DATABASE_URL'] ?? throw new \\RuntimeException('DATABASE_URL is not defined'); } [!NOTE] You can find more about how .env file loading and overloading works on related Symfony documentation . Create a context from a .env file You can also create a context that load a .env file: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\load_dot_env; #[AsContext()] function my_context(): Context { return new Context(load_dot_env()); }","title":"Using .env files"},{"location":"going-further/dot-env/#using-env-files","text":"","title":"Using .env files"},{"location":"going-further/dot-env/#the-load_dot_env-function","text":"You can load a .env file with the load_dot_env() function. This will: - load the .env file - populate the env variables for the current process - return the env variables as key/value array. [!NOTE] By default, it loads the .env file on your project root (where castor file or folder was found), but you can overload this by passing your .env file path as an argument. Example: use Castor\\Attribute\\AsTask; use Castor\\Context; use function Castor\\load_dot_env; #[AsTask()] function show_database_url(): void { $env = load_dot_env(); echo $env['DATABASE_URL'] ?? throw new \\RuntimeException('DATABASE_URL is not defined'); } [!NOTE] You can find more about how .env file loading and overloading works on related Symfony documentation .","title":"The load_dot_env() function"},{"location":"going-further/dot-env/#create-a-context-from-a-env-file","text":"You can also create a context that load a .env file: use Castor\\Attribute\\AsContext; use Castor\\Context; use function Castor\\load_dot_env; #[AsContext()] function my_context(): Context { return new Context(load_dot_env()); }","title":"Create a context from a .env file"},{"location":"going-further/events/","text":"Listening to events Castor provides utilities to listen and react when event happened inside your project. It allows to implement custom logic at various points in the application lifecycle. Registering a listener You can register a listener inside your Castor project by using the Castor\\Attribute\\AsListener attribute. This attribute allows you to specify the targeted event and the priority of this listener. #[AsListener(event: AfterApplicationInitializationEvent::class)] #[AsListener(event: AfterExecuteTaskEvent::class, priority: 1)] function my_event_listener(AfterApplicationInitializationEvent|AfterExecuteTaskEvent $event): void { // Custom logic to handle the events } [!NOTE] You can specify multiple events for a single listener. [!NOTE] The priority argument is optional and defaults to 0 . The higher the priority, the earlier the listener will be executed. Built-in events Here is the built-in events triggered by Castor: Castor\\Event\\AfterApplicationInitializationEvent : This event is triggered after the application has been initialized. It provides access to the Application instance and an array of TaskDescriptor objects; Castor\\Event\\BeforeExecuteTaskEvent : This event is triggered before executing a task. It provides access to the TaskCommand instance; Castor\\Event\\AfterExecuteTaskEvent : This event is triggered after executing a task. It provides access to the TaskCommand instance.","title":"Listening to events"},{"location":"going-further/events/#listening-to-events","text":"Castor provides utilities to listen and react when event happened inside your project. It allows to implement custom logic at various points in the application lifecycle.","title":"Listening to events"},{"location":"going-further/events/#registering-a-listener","text":"You can register a listener inside your Castor project by using the Castor\\Attribute\\AsListener attribute. This attribute allows you to specify the targeted event and the priority of this listener. #[AsListener(event: AfterApplicationInitializationEvent::class)] #[AsListener(event: AfterExecuteTaskEvent::class, priority: 1)] function my_event_listener(AfterApplicationInitializationEvent|AfterExecuteTaskEvent $event): void { // Custom logic to handle the events } [!NOTE] You can specify multiple events for a single listener. [!NOTE] The priority argument is optional and defaults to 0 . The higher the priority, the earlier the listener will be executed.","title":"Registering a listener"},{"location":"going-further/events/#built-in-events","text":"Here is the built-in events triggered by Castor: Castor\\Event\\AfterApplicationInitializationEvent : This event is triggered after the application has been initialized. It provides access to the Application instance and an array of TaskDescriptor objects; Castor\\Event\\BeforeExecuteTaskEvent : This event is triggered before executing a task. It provides access to the TaskCommand instance; Castor\\Event\\AfterExecuteTaskEvent : This event is triggered after executing a task. It provides access to the TaskCommand instance.","title":"Built-in events"},{"location":"going-further/filesystem/","text":"Filesystem The fs() function The fs() function returns an object that provides OS-independent utilities for filesystem operations and for file/directory paths manipulation. It returns an instance of Symfony\\Component\\Filesystem\\Filesystem . You can also use static methods of the class Symfony\\Component\\Filesystem\\Path : use Castor\\Attribute\\AsTask; use Symfony\\Component\\Filesystem\\Path; use function Castor\\fs; #[AsTask()] function foo() { $dir = '/tmp/foo'; echo $dir, ' directory exist: ', fs()->exists($dir) ? 'yes' : 'no', \\PHP_EOL; fs()->mkdir($dir); fs()->touch($dir . '/bar.md'); echo $dir, ' is an absolute path: ', Path::isAbsolute($dir) ? 'yes' : 'no', \\PHP_EOL; echo '../ is an absolute path: ', Path::isAbsolute('../') ? 'yes' : 'no', \\PHP_EOL; fs()->remove($dir); echo 'Absolute path: ', Path::makeAbsolute('../', $dir), \\PHP_EOL; } [!NOTE] You can check the Symfony documentation for more information about this component and how to use it. The finder() function The finder() function returns an object that finds files and directories based on different criteria (name, file size, modification time, etc.) via an intuitive fluent interface. It returns an instance of Symfony\\Component\\Finder\\Finder : use Castor\\Attribute\\AsTask; use function Castor\\finder; #[AsTask()] function foo() { echo 'Number of PHP files: ', finder()->name('*.php')->in(__DIR__)->count(), \\PHP_EOL; } [!NOTE] You can check the Symfony documentation for more information about this class and how to use it.","title":"Filesystem"},{"location":"going-further/filesystem/#filesystem","text":"","title":"Filesystem"},{"location":"going-further/filesystem/#the-fs-function","text":"The fs() function returns an object that provides OS-independent utilities for filesystem operations and for file/directory paths manipulation. It returns an instance of Symfony\\Component\\Filesystem\\Filesystem . You can also use static methods of the class Symfony\\Component\\Filesystem\\Path : use Castor\\Attribute\\AsTask; use Symfony\\Component\\Filesystem\\Path; use function Castor\\fs; #[AsTask()] function foo() { $dir = '/tmp/foo'; echo $dir, ' directory exist: ', fs()->exists($dir) ? 'yes' : 'no', \\PHP_EOL; fs()->mkdir($dir); fs()->touch($dir . '/bar.md'); echo $dir, ' is an absolute path: ', Path::isAbsolute($dir) ? 'yes' : 'no', \\PHP_EOL; echo '../ is an absolute path: ', Path::isAbsolute('../') ? 'yes' : 'no', \\PHP_EOL; fs()->remove($dir); echo 'Absolute path: ', Path::makeAbsolute('../', $dir), \\PHP_EOL; } [!NOTE] You can check the Symfony documentation for more information about this component and how to use it.","title":"The fs() function"},{"location":"going-further/filesystem/#the-finder-function","text":"The finder() function returns an object that finds files and directories based on different criteria (name, file size, modification time, etc.) via an intuitive fluent interface. It returns an instance of Symfony\\Component\\Finder\\Finder : use Castor\\Attribute\\AsTask; use function Castor\\finder; #[AsTask()] function foo() { echo 'Number of PHP files: ', finder()->name('*.php')->in(__DIR__)->count(), \\PHP_EOL; } [!NOTE] You can check the Symfony documentation for more information about this class and how to use it.","title":"The finder() function"},{"location":"going-further/fingerprint/","text":"Fingerprinting and code execution when something changes Castor provides a fingerprint functionality to execute tasks only if something changed. To detect whether something has changed, Castor uses a fingerprint that can be anything like a string content, the hash of a file or a group of files (based on content or modification time), etc. The fingerprint() function You can use the fingerprint() function to conditionally execute a callback if the given fingerprint has changed. use Castor\\Attribute\\AsTask; use function Castor\\fingerprint; use function Castor\\run; #[AsTask(description: 'Execute a callback only if the fingerprint has changed')] function task_with_a_fingerprint(): void { fingerprint( callback: function () { run('echo \"Cool, no fingerprint! Executing...\"'); }, fingerprint: \"my fingerprint\", ); } [!NOTE] You can use the $force parameter of the fingerprint() function to force the execution of the callback even if the fingerprint has not changed. The hasher() function Most of the time, you will want your fingerprint hash to be based on the content of a file, to scope it to a specific task or something else. To help you compute this hash, Castor provides a hasher() function. It returns an instance of Castor\\HasherHelper with various helper methods: write() : Writes a hash of a specific (string) value. writeFile() : Writes a hash of a file content or its modification time. writeWithFinder() : Writes a hash of a group of files obtained through Finder . writeGlob() : Writes a hash of a group of files obtained via a glob pattern. writeTaskName() : Writes the name of the current task. writeTaskArgs() : Writes arguments passed to the current task. writeTask() : Writes a combination of the current task name and arguments. finish() : Finalizes the hash operation, returning a string of the hash. The methods writeFile() , writeWithFinder() and writeGlob() accept a second parameter $strategy to specify on with criteria the hash should be based on. This parameter is a Castor\\Fingerprint\\FileHashStrategy enum that contains two values: - Content will make the hash dependent on the file's content - MTimes will make the hash depend on the file's last modification time. This is the default strategy. Example usage: use Castor\\Attribute\\AsTask; use Castor\\Fingerprint\\FileHashStrategy; use function Castor\\fingerprint; use function Castor\\hasher; #[AsTask(description: 'Execute a callback only if the fingerprint has changed')] function task_with_a_fingerprint(): void { fingerprint( callback: function () { run('echo \"Executing the callback because my-file.json has changed.\"'); }, fingerprint: hasher()->writeFile('my-file.json', FileHashStrategy::Content)->finish(), ); } The fingerprint_exists() and fingerprint_save() functions If you want more control over the fingerprint behaviour, you can use the fingerprint_exists() and fingerprint_save() functions to conditionally execute your code: use Castor\\Attribute\\AsTask; use Castor\\Fingerprint\\FileHashStrategy; use function Castor\\finder; use function Castor\\fingerprint_exists; use function Castor\\fingerprint_save; use function Castor\\hasher; #[AsTask(description: 'Check if the fingerprint has changed before executing some code')] function task_with_some_fingerprint(): void { if (!fingerprint_exists(my_fingerprint_check())) { run('echo \"Executing some code because fingerprint has changed.\"'); fingerprint_save(my_fingerprint_check()); } } function my_fingerprint_check(): string { return hasher() ->writeWithFinder( finder() ->in(__DIR__) ->name('*.json') ->files(), FileHashStrategy::Content ) ->finish(); }","title":"Fingerprinting and code execution when something changes"},{"location":"going-further/fingerprint/#fingerprinting-and-code-execution-when-something-changes","text":"Castor provides a fingerprint functionality to execute tasks only if something changed. To detect whether something has changed, Castor uses a fingerprint that can be anything like a string content, the hash of a file or a group of files (based on content or modification time), etc.","title":"Fingerprinting and code execution when something changes"},{"location":"going-further/fingerprint/#the-fingerprint-function","text":"You can use the fingerprint() function to conditionally execute a callback if the given fingerprint has changed. use Castor\\Attribute\\AsTask; use function Castor\\fingerprint; use function Castor\\run; #[AsTask(description: 'Execute a callback only if the fingerprint has changed')] function task_with_a_fingerprint(): void { fingerprint( callback: function () { run('echo \"Cool, no fingerprint! Executing...\"'); }, fingerprint: \"my fingerprint\", ); } [!NOTE] You can use the $force parameter of the fingerprint() function to force the execution of the callback even if the fingerprint has not changed.","title":"The fingerprint() function"},{"location":"going-further/fingerprint/#the-hasher-function","text":"Most of the time, you will want your fingerprint hash to be based on the content of a file, to scope it to a specific task or something else. To help you compute this hash, Castor provides a hasher() function. It returns an instance of Castor\\HasherHelper with various helper methods: write() : Writes a hash of a specific (string) value. writeFile() : Writes a hash of a file content or its modification time. writeWithFinder() : Writes a hash of a group of files obtained through Finder . writeGlob() : Writes a hash of a group of files obtained via a glob pattern. writeTaskName() : Writes the name of the current task. writeTaskArgs() : Writes arguments passed to the current task. writeTask() : Writes a combination of the current task name and arguments. finish() : Finalizes the hash operation, returning a string of the hash. The methods writeFile() , writeWithFinder() and writeGlob() accept a second parameter $strategy to specify on with criteria the hash should be based on. This parameter is a Castor\\Fingerprint\\FileHashStrategy enum that contains two values: - Content will make the hash dependent on the file's content - MTimes will make the hash depend on the file's last modification time. This is the default strategy. Example usage: use Castor\\Attribute\\AsTask; use Castor\\Fingerprint\\FileHashStrategy; use function Castor\\fingerprint; use function Castor\\hasher; #[AsTask(description: 'Execute a callback only if the fingerprint has changed')] function task_with_a_fingerprint(): void { fingerprint( callback: function () { run('echo \"Executing the callback because my-file.json has changed.\"'); }, fingerprint: hasher()->writeFile('my-file.json', FileHashStrategy::Content)->finish(), ); }","title":"The hasher() function"},{"location":"going-further/fingerprint/#the-fingerprint_exists-and-fingerprint_save-functions","text":"If you want more control over the fingerprint behaviour, you can use the fingerprint_exists() and fingerprint_save() functions to conditionally execute your code: use Castor\\Attribute\\AsTask; use Castor\\Fingerprint\\FileHashStrategy; use function Castor\\finder; use function Castor\\fingerprint_exists; use function Castor\\fingerprint_save; use function Castor\\hasher; #[AsTask(description: 'Check if the fingerprint has changed before executing some code')] function task_with_some_fingerprint(): void { if (!fingerprint_exists(my_fingerprint_check())) { run('echo \"Executing some code because fingerprint has changed.\"'); fingerprint_save(my_fingerprint_check()); } } function my_fingerprint_check(): string { return hasher() ->writeWithFinder( finder() ->in(__DIR__) ->name('*.json') ->files(), FileHashStrategy::Content ) ->finish(); }","title":"The fingerprint_exists() and fingerprint_save() functions"},{"location":"going-further/http-request/","text":"HTTP requests The request() function The request() function allows to make HTTP requests easily. It performs HTTP request and returns an instance of Symfony\\Contracts\\HttpClient\\ResponseInterface : use Castor\\Attribute\\AsTask; use function Castor\\request; #[AsTask()] function foo() { echo request('GET', 'https://example.org')->getContent(), \\PHP_EOL; } The http_client() function If you need to have a full control on the HTTP client, you can access the HttpClientInterface directly with the http_client() function: use Castor\\Attribute\\AsTask; use function Castor\\http_client; #[AsTask()] function foo() { $client = http_client() ->withOptions([ 'verify_peer' => false, 'timeout' => 10, ]) ; } You can check the Symfony documentation for more information about this component and how to use it.","title":"HTTP requests"},{"location":"going-further/http-request/#http-requests","text":"","title":"HTTP requests"},{"location":"going-further/http-request/#the-request-function","text":"The request() function allows to make HTTP requests easily. It performs HTTP request and returns an instance of Symfony\\Contracts\\HttpClient\\ResponseInterface : use Castor\\Attribute\\AsTask; use function Castor\\request; #[AsTask()] function foo() { echo request('GET', 'https://example.org')->getContent(), \\PHP_EOL; }","title":"The request() function"},{"location":"going-further/http-request/#the-http_client-function","text":"If you need to have a full control on the HTTP client, you can access the HttpClientInterface directly with the http_client() function: use Castor\\Attribute\\AsTask; use function Castor\\http_client; #[AsTask()] function foo() { $client = http_client() ->withOptions([ 'verify_peer' => false, 'timeout' => 10, ]) ; } You can check the Symfony documentation for more information about this component and how to use it.","title":"The http_client() function"},{"location":"going-further/log/","text":"Log and Debug Castor has logging capabilities. It relies on Monolog and is also configured with Symfony Console . There are different log levels, and you can control the log level displayed with the -v option: castor # display level \"warning\" and above castor -v # display level \"notice\" and above castor -vv # display level \"info\" and above castor -vvv # display level \"debug\" and above When an error occurs, the error message is displayed and the program exits. If you need more information, you can re-run the task with the -v option. The log() function You can use the log() function to log a message: use Castor\\Attribute\\AsTask; use function Castor\\log; #[AsTask()] function log() { log('Error!, this is an \"error\" log message.', 'error'); } You can also attach a context to the log message: use Castor\\Attribute\\AsTask; use function Castor\\log; #[AsTask()] function log() { log('Hello, I\\'have a context!', 'error', context: [ 'date' => new \\DateTimeImmutable(), ]); } Log something - the right way You may wonder when to use the log() or io() functions or even echo to output something. Here is a small guide: Don't use PHP's native echo instruction, it's not a good practice; Use the io() function to display something to the user thanks to Symfony's SymfonyStyle class; Use the log() function when you want to add some debug information. The logger() function If you need to access the raw logger instance, you can get it with the logger() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use Castor\\PathHelper; use Monolog\\Handler\\StreamHandler; use function Castor\\logger; #[AsContext(name: 'preprod')] function preprodContext(): Context { logger()->pushHandler(new StreamHandler(PathHelper::getRoot() . '/preprod.log')); //return new Context(...); } The debug task Castor ships a debug task that displays the current context, the root directory, the cache directory, and more information. Run with: castor debug If you want to define your own debug command, you can still access to the castor task with: castor castor:debug","title":"Log and Debug"},{"location":"going-further/log/#log-and-debug","text":"Castor has logging capabilities. It relies on Monolog and is also configured with Symfony Console . There are different log levels, and you can control the log level displayed with the -v option: castor # display level \"warning\" and above castor -v # display level \"notice\" and above castor -vv # display level \"info\" and above castor -vvv # display level \"debug\" and above When an error occurs, the error message is displayed and the program exits. If you need more information, you can re-run the task with the -v option.","title":"Log and Debug"},{"location":"going-further/log/#the-log-function","text":"You can use the log() function to log a message: use Castor\\Attribute\\AsTask; use function Castor\\log; #[AsTask()] function log() { log('Error!, this is an \"error\" log message.', 'error'); } You can also attach a context to the log message: use Castor\\Attribute\\AsTask; use function Castor\\log; #[AsTask()] function log() { log('Hello, I\\'have a context!', 'error', context: [ 'date' => new \\DateTimeImmutable(), ]); }","title":"The log() function"},{"location":"going-further/log/#log-something-the-right-way","text":"You may wonder when to use the log() or io() functions or even echo to output something. Here is a small guide: Don't use PHP's native echo instruction, it's not a good practice; Use the io() function to display something to the user thanks to Symfony's SymfonyStyle class; Use the log() function when you want to add some debug information.","title":"Log something - the right way"},{"location":"going-further/log/#the-logger-function","text":"If you need to access the raw logger instance, you can get it with the logger() function: use Castor\\Attribute\\AsContext; use Castor\\Context; use Castor\\PathHelper; use Monolog\\Handler\\StreamHandler; use function Castor\\logger; #[AsContext(name: 'preprod')] function preprodContext(): Context { logger()->pushHandler(new StreamHandler(PathHelper::getRoot() . '/preprod.log')); //return new Context(...); }","title":"The logger() function"},{"location":"going-further/log/#the-debug-task","text":"Castor ships a debug task that displays the current context, the root directory, the cache directory, and more information. Run with: castor debug If you want to define your own debug command, you can still access to the castor task with: castor castor:debug","title":"The debug task"},{"location":"going-further/notify/","text":"Notification Castor uses the JoliNotif library to display notifications. The notify() function You can use the notify() function to display a desktop notification: use Castor\\Attribute\\AsTask; use function Castor\\notify; #[AsTask()] function notify() { notify('Hello world!'); } Notify with run() You can use the notify argument of the run() function to display a notification when a command has been executed: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function notify() { run(['echo', 'notify'], notify: true); // will display a success notification run('command_that_does_not_exist', notify: true); // will display a failure notification }","title":"Notification"},{"location":"going-further/notify/#notification","text":"Castor uses the JoliNotif library to display notifications.","title":"Notification"},{"location":"going-further/notify/#the-notify-function","text":"You can use the notify() function to display a desktop notification: use Castor\\Attribute\\AsTask; use function Castor\\notify; #[AsTask()] function notify() { notify('Hello world!'); }","title":"The notify() function"},{"location":"going-further/notify/#notify-with-run","text":"You can use the notify argument of the run() function to display a notification when a command has been executed: use Castor\\Attribute\\AsTask; use function Castor\\run; #[AsTask()] function notify() { run(['echo', 'notify'], notify: true); // will display a success notification run('command_that_does_not_exist', notify: true); // will display a failure notification }","title":"Notify with run()"},{"location":"going-further/parallel/","text":"Parallel execution The parallel() function The parallel() function provides a way to run functions in parallel, so you do not have to wait for a function to finish before starting another one: use Castor\\Attribute\\AsTask; use function Castor\\parallel; #[AsTask()] function foo(): void { [$foo, $bar] = parallel( function () { return run('sleep 2 && echo foo', quiet: true); }, function () { return run('sleep 2 && echo bar', quiet: true); } ); echo $foo->getOutput(); // will print foo echo $bar->getOutput(); // will print bar } The parallel() function use the \\Fiber class to run the functions in parallel. [!NOTE] The code is not executed in parallel. Only functions using this concept will be executed in parallel, which is the case for the run() and watch() function. Watching in parallel You can also watch in parallel multiple directories: ```php use Castor\\Attribute\\AsTask; use function Castor\\parallel; [AsTask()] function parallel_change() { parallel( function () { watch('src/...', function (string $file, string $action) { // do something on src file change }); }, function () { watch('doc/...', function (string $file, string $action) { // do something on doc file change }); }, ); }","title":"Parallel execution"},{"location":"going-further/parallel/#parallel-execution","text":"","title":"Parallel execution"},{"location":"going-further/parallel/#the-parallel-function","text":"The parallel() function provides a way to run functions in parallel, so you do not have to wait for a function to finish before starting another one: use Castor\\Attribute\\AsTask; use function Castor\\parallel; #[AsTask()] function foo(): void { [$foo, $bar] = parallel( function () { return run('sleep 2 && echo foo', quiet: true); }, function () { return run('sleep 2 && echo bar', quiet: true); } ); echo $foo->getOutput(); // will print foo echo $bar->getOutput(); // will print bar } The parallel() function use the \\Fiber class to run the functions in parallel. [!NOTE] The code is not executed in parallel. Only functions using this concept will be executed in parallel, which is the case for the run() and watch() function.","title":"The parallel() function"},{"location":"going-further/parallel/#watching-in-parallel","text":"You can also watch in parallel multiple directories: ```php use Castor\\Attribute\\AsTask; use function Castor\\parallel;","title":"Watching in parallel"},{"location":"going-further/parallel/#astask","text":"function parallel_change() { parallel( function () { watch('src/...', function (string $file, string $action) { // do something on src file change }); }, function () { watch('doc/...', function (string $file, string $action) { // do something on doc file change }); }, ); }","title":"[AsTask()]"},{"location":"going-further/repack/","text":"Repacking your application in a new phar You have created a Castor application, with many tasks, and you want to distribute it as a single phar file? Castor can help you with that. Pre-requisites In your project, install Castor as a dependency: composer require jolicode/castor You'll also need box to create the phar. The box binary must be available in your path. You'll also need to ensure the phar creation is allowed by your PHP configuration. See the PHP documentation to disabled phar.readonly . Running the Repack Command Then, run the repack command to create the new phar: vendor/bin/castor repack See the help for more options: vendor/bin/castor repack --help [!NOTE] Castor will automatically import all files in the current directly. So ensure to have the less files possible in the directory where you run the repack task to avoid including useless files in the phar. Going further Packaging your Castor app as a phar simplifies distribution but requires PHP setup on target systems. Castor's compile command streamlines this by embedding the phar in a PHP binary, creating a standalone executable for diverse environments.","title":"Repacking your application in a new phar"},{"location":"going-further/repack/#repacking-your-application-in-a-new-phar","text":"You have created a Castor application, with many tasks, and you want to distribute it as a single phar file? Castor can help you with that.","title":"Repacking your application in a new phar"},{"location":"going-further/repack/#pre-requisites","text":"In your project, install Castor as a dependency: composer require jolicode/castor You'll also need box to create the phar. The box binary must be available in your path. You'll also need to ensure the phar creation is allowed by your PHP configuration. See the PHP documentation to disabled phar.readonly .","title":"Pre-requisites"},{"location":"going-further/repack/#running-the-repack-command","text":"Then, run the repack command to create the new phar: vendor/bin/castor repack See the help for more options: vendor/bin/castor repack --help [!NOTE] Castor will automatically import all files in the current directly. So ensure to have the less files possible in the directory where you run the repack task to avoid including useless files in the phar.","title":"Running the Repack Command"},{"location":"going-further/repack/#going-further","text":"Packaging your Castor app as a phar simplifies distribution but requires PHP setup on target systems. Castor's compile command streamlines this by embedding the phar in a PHP binary, creating a standalone executable for diverse environments.","title":"Going further"},{"location":"going-further/signals/","text":"Handling signals Castor can handle signals sent to the process. This is useful to gracefully stop a task when the user presses CTRL+C or to handle other signals: use Castor\\Attribute\\AsTask; #[AsTask(onSignals: [\\SIGUSR2 => 'onSigUsr2'])] function foo(): void { // Do something... } function onSigUsr2(int $signal): int|false { echo \"SIGUSR2 received\\n\"; return false; } Return false to continue the task, or return an integer to stop the task with this exit code. If the task is in a namespace, you must use the fully qualified name of the function: namespace signal; use Castor\\Attribute\\AsTask; #[AsTask(onSignals: [\\SIGUSR2 => 'signal\\onSigUsr2'])] function foo(): void { // Do something... } function onSigUsr2(int $signal): int|false { echo \"SIGUSR2 received\\n\"; return false; }","title":"Handling signals"},{"location":"going-further/signals/#handling-signals","text":"Castor can handle signals sent to the process. This is useful to gracefully stop a task when the user presses CTRL+C or to handle other signals: use Castor\\Attribute\\AsTask; #[AsTask(onSignals: [\\SIGUSR2 => 'onSigUsr2'])] function foo(): void { // Do something... } function onSigUsr2(int $signal): int|false { echo \"SIGUSR2 received\\n\"; return false; } Return false to continue the task, or return an integer to stop the task with this exit code. If the task is in a namespace, you must use the fully qualified name of the function: namespace signal; use Castor\\Attribute\\AsTask; #[AsTask(onSignals: [\\SIGUSR2 => 'signal\\onSigUsr2'])] function foo(): void { // Do something... } function onSigUsr2(int $signal): int|false { echo \"SIGUSR2 received\\n\"; return false; }","title":"Handling signals"},{"location":"going-further/ssh/","text":"SSH and remote servers Castor provide several ssh_* functions to run SSH commands on remote servers or upload/download files through SCP. [!NOTE] These functions are marked as experimental and may change in the future. Common parameters The following parameters are common to all of the ssh_x() functions: $host (string): Host to connect to. $user (string): User to connect with. $ssh_options (array): Optional configuration of the connexion. The ssh_options argument supports the following options: port (int): port to use to connect to the remote server (default: 22) path_private_key (string): path to the private key to use to connect to the remote server jump_host (string): host to use as a jump host multiplexing_control_path (string): path to the control socket for multiplexing connections multiplexing_control_persist (string): whether to persist the control socket for multiplexing connections or idle time after which the backgrounded master connection will automatically terminate (default: no) enable_strict_check (bool): whether to enable strict host key checking (default: true) password_authentication (bool): whether to use password authentication (default: false) The ssh_run() function Castor supports running commands on remote servers through SSH with the ssh_run() function: use Castor\\Attribute\\AsTask; use function Castor\\ssh_run; #[AsTask()] function ls(): void { // List content of /var/www directory on the remote server ssh_run('ls -alh', host: 'server-1.example.com', user: 'debian', sshOptions: [ 'port' => 2222, ], path: '/var/www'); } [!NOTE] This feature is marked as experimental and may change in the future. Upload and download files Castor provides 2 functions ssh_upload() and ssh_download() to exchange files between localhost and a remote server: The ssh_upload() function use function Castor\\ssh_upload; #[AsTask()] function upload_file(): void { ssh_upload('/tmp/test.html', '/var/www/index.html', host: 'server-1.example.com', user: 'debian'); } The ssh_download() function use function Castor\\ssh_download; #[AsTask()] function download_file(): void { ssh_download('/tmp/test.html', '/var/www/index.html', host: 'server-1.example.com', user: 'debian'); }","title":"SSH and remote servers"},{"location":"going-further/ssh/#ssh-and-remote-servers","text":"Castor provide several ssh_* functions to run SSH commands on remote servers or upload/download files through SCP. [!NOTE] These functions are marked as experimental and may change in the future.","title":"SSH and remote servers"},{"location":"going-further/ssh/#common-parameters","text":"The following parameters are common to all of the ssh_x() functions: $host (string): Host to connect to. $user (string): User to connect with. $ssh_options (array): Optional configuration of the connexion. The ssh_options argument supports the following options: port (int): port to use to connect to the remote server (default: 22) path_private_key (string): path to the private key to use to connect to the remote server jump_host (string): host to use as a jump host multiplexing_control_path (string): path to the control socket for multiplexing connections multiplexing_control_persist (string): whether to persist the control socket for multiplexing connections or idle time after which the backgrounded master connection will automatically terminate (default: no) enable_strict_check (bool): whether to enable strict host key checking (default: true) password_authentication (bool): whether to use password authentication (default: false)","title":"Common parameters"},{"location":"going-further/ssh/#the-ssh_run-function","text":"Castor supports running commands on remote servers through SSH with the ssh_run() function: use Castor\\Attribute\\AsTask; use function Castor\\ssh_run; #[AsTask()] function ls(): void { // List content of /var/www directory on the remote server ssh_run('ls -alh', host: 'server-1.example.com', user: 'debian', sshOptions: [ 'port' => 2222, ], path: '/var/www'); } [!NOTE] This feature is marked as experimental and may change in the future.","title":"The ssh_run() function"},{"location":"going-further/ssh/#upload-and-download-files","text":"Castor provides 2 functions ssh_upload() and ssh_download() to exchange files between localhost and a remote server:","title":"Upload and download files"},{"location":"going-further/ssh/#the-ssh_upload-function","text":"use function Castor\\ssh_upload; #[AsTask()] function upload_file(): void { ssh_upload('/tmp/test.html', '/var/www/index.html', host: 'server-1.example.com', user: 'debian'); }","title":"The ssh_upload() function"},{"location":"going-further/ssh/#the-ssh_download-function","text":"use function Castor\\ssh_download; #[AsTask()] function download_file(): void { ssh_download('/tmp/test.html', '/var/www/index.html', host: 'server-1.example.com', user: 'debian'); }","title":"The ssh_download() function"},{"location":"going-further/symfony-task/","text":"Symfony Task If your Castor project lives near a Symfony application, you may want to use some of its commands directly as Castor tasks. This is possible with the AsSymfonyTask attribute you can set on your command class. [!NOTE] Thanks to how PHP attributes works, your application will work even if it does not find this attribute class (which will probably not be available on your vendor directory - unless you installed Castor with Composer). use Castor\\Attribute\\AsSymfonyTask; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Commhearand\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; #[AsCommand('hello', 'Says hello from a Symfony application')] #[AsSymfonyTask(name: 'symfony:hello')] class HelloCommand extends Command { protected function execute(InputInterface $input, OutputInterface $output): int { $output->writeln('Hello'); return 0; } } By default, the attribute will re-use the same name as the one defined in the Symfony application, but you can override it with the name parameter. If Symfony command does own a AsCommand attribute, you must set the originName parameter, and it must be the same as the same in the symfony application. And finally, you can give a way to access the Symfony application entry point with the console parameter. Some examples: ['bin/console'] , this is the default, when Symfony and Castor live in the very same directory ['path/to/symfony/bin/console'] , when Symfony is in another directory ['docker', 'exec', 'foobar-backend-1', '/app/server/backend/bin/console'] , when your Symfony application lives in a docker container","title":"Symfony Task"},{"location":"going-further/symfony-task/#symfony-task","text":"If your Castor project lives near a Symfony application, you may want to use some of its commands directly as Castor tasks. This is possible with the AsSymfonyTask attribute you can set on your command class. [!NOTE] Thanks to how PHP attributes works, your application will work even if it does not find this attribute class (which will probably not be available on your vendor directory - unless you installed Castor with Composer). use Castor\\Attribute\\AsSymfonyTask; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Commhearand\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; #[AsCommand('hello', 'Says hello from a Symfony application')] #[AsSymfonyTask(name: 'symfony:hello')] class HelloCommand extends Command { protected function execute(InputInterface $input, OutputInterface $output): int { $output->writeln('Hello'); return 0; } } By default, the attribute will re-use the same name as the one defined in the Symfony application, but you can override it with the name parameter. If Symfony command does own a AsCommand attribute, you must set the originName parameter, and it must be the same as the same in the symfony application. And finally, you can give a way to access the Symfony application entry point with the console parameter. Some examples: ['bin/console'] , this is the default, when Symfony and Castor live in the very same directory ['path/to/symfony/bin/console'] , when Symfony is in another directory ['docker', 'exec', 'foobar-backend-1', '/app/server/backend/bin/console'] , when your Symfony application lives in a docker container","title":"Symfony Task"},{"location":"going-further/version-check/","text":"Guard to check the version of castor The guard_min_version() function use function Castor\\guard_min_version; guard_min_version('v0.11.0'); This function will throw an exception if the current version of Castor is lower (e.g. 0.10.0 ). That will force the user to update Castor before running the command. This is useful when you want to use a new feature of Castor in your command. And you want to ensure that the user has the right version of Castor. [!NOTE] Where to put this function? It depends on your usage. If you want to ensure that the user has the right version of Castor before running any task, you can put it in the top of your castor.php file. If you want to ensure that the user has the right version of Castor before running a specific task, you can put it in the task function directly and check will be done only when the task is called. You can go further with Events and Listeners to check certain conditions by checking a pattern task name.","title":"Guard to check the version of castor"},{"location":"going-further/version-check/#guard-to-check-the-version-of-castor","text":"","title":"Guard to check the version of castor"},{"location":"going-further/version-check/#the-guard_min_version-function","text":"use function Castor\\guard_min_version; guard_min_version('v0.11.0'); This function will throw an exception if the current version of Castor is lower (e.g. 0.10.0 ). That will force the user to update Castor before running the command. This is useful when you want to use a new feature of Castor in your command. And you want to ensure that the user has the right version of Castor. [!NOTE] Where to put this function? It depends on your usage. If you want to ensure that the user has the right version of Castor before running any task, you can put it in the top of your castor.php file. If you want to ensure that the user has the right version of Castor before running a specific task, you can put it in the task function directly and check will be done only when the task is called. You can go further with Events and Listeners to check certain conditions by checking a pattern task name.","title":"The guard_min_version() function"},{"location":"going-further/wait-for/","text":"Waiting for things wait_for and wait_for_* functions are designed to help developers handle various case where waiting is necessary (e.g. waiting for a condition to be satisfied, for a port to be accessible, etc.). Common parameters The following parameters are common to most of the functions: $timeout (int): Timeout duration in seconds. Default is 10 seconds. $quiet (bool): Whether to suppress output. Default is false. $intervalMs (int): Interval between checks in milliseconds. Default is 100. $message (?string): Custom message to display before waiting. Default is null. How to handle when the condition is met or when timeout is reached The wait_for and wait_for_* functions throw a WaitForTimeoutException exception when the timeout is reached. You can catch this exception and handle it accordingly. Example: try { wait_for(...); // wait_for_port, wait_for_url, wait_for_http_status, etc. } catch (WaitForTimeoutException $e) { // Handle timeout } Usage The wait_for() function The wait_for() method is a general-purpose waiting function. It takes a callback function as its first parameter, representing the condition to be met. The function will repeatedly call this callback until the condition is met or the specified timeout is reached. wait_for( callback: function () { // Your custom condition/callback logic here return true; // Change this based on your condition }, timeout: 10, quiet: false, intervalMs: 100, message: 'Waiting for something to happen...', ); [!NOTE] you can also return null if you want to abort the waiting process. The function will throw an exception if the callback returns null. The wait_for_port() function The wait_for_port() method waits for a network port to be accessible. It checks if a connection can be established to the specified port on a given host within the specified timeout. The method allows customization by providing options such as the host. Example: wait_for_port( port: 8080, host: '127.0.0.1', timeout: 15, quiet: false, intervalMs: 500, message: 'Waiting for port localhost:8080 to be accessible...', ); The wait_for_url() function The wait_for_url() method waits for a URL to be accessible. It attempts to open a connection to the specified URL within the specified timeout. wait_for_url( url: 'https://example.com', timeout: 10, quiet: false, intervalMs: 200, message: 'Waiting for https://example.com to be accessible...', ); The wait_for_http_response() function The wait_for_http_response() function waits for a specified URL to return a response assessed using a user-defined $responseChecker callback function. It allows for a detailed validation of the response content. Example validating the status code and the response content: wait_for_http_response( url: 'https://example.com', responseChecker: function (ResponseInterface $response) { return $response->getStatusCode() !== 200 && u($response->getContent())->containsAny(['Example Domain']); }, timeout: 2, ); The wait_for_http_status() function The wait_for_http_status() function is a specialized version of wait_for_http_response() , specifically designed to monitor a URL until it returns a desired HTTP status code. Example: wait_for_http_status( url: 'https://example.com/api', status: 200, timeout: 10, quiet: false, intervalMs: 300, message: 'Waiting for https://example.com/api to return HTTP 200', ); The wait_for_docker_container() function The wait_for_docker_container() function waits for a Docker container to be ready. It checks if the container is running and if the specified port is accessible within the specified timeout. It can also wait for a specific check to be successful, by providing a $check callback function. Example: wait_for_docker_container( container: 'mysql-container', containerChecker: function ($containerId) { return run(\"docker exec $containerId mysql -uroot -proot -e 'SELECT 1'\", allowFailure: true)->isSuccessful(); }, portsToCheck: [3306] timeout: 30, quiet: false, intervalMs: 100, message: 'Waiting for my-container to be ready...', );","title":"Waiting for things"},{"location":"going-further/wait-for/#waiting-for-things","text":"wait_for and wait_for_* functions are designed to help developers handle various case where waiting is necessary (e.g. waiting for a condition to be satisfied, for a port to be accessible, etc.).","title":"Waiting for things"},{"location":"going-further/wait-for/#common-parameters","text":"The following parameters are common to most of the functions: $timeout (int): Timeout duration in seconds. Default is 10 seconds. $quiet (bool): Whether to suppress output. Default is false. $intervalMs (int): Interval between checks in milliseconds. Default is 100. $message (?string): Custom message to display before waiting. Default is null.","title":"Common parameters"},{"location":"going-further/wait-for/#how-to-handle-when-the-condition-is-met-or-when-timeout-is-reached","text":"The wait_for and wait_for_* functions throw a WaitForTimeoutException exception when the timeout is reached. You can catch this exception and handle it accordingly. Example: try { wait_for(...); // wait_for_port, wait_for_url, wait_for_http_status, etc. } catch (WaitForTimeoutException $e) { // Handle timeout }","title":"How to handle when the condition is met or when timeout is reached"},{"location":"going-further/wait-for/#usage","text":"","title":"Usage"},{"location":"going-further/wait-for/#the-wait_for-function","text":"The wait_for() method is a general-purpose waiting function. It takes a callback function as its first parameter, representing the condition to be met. The function will repeatedly call this callback until the condition is met or the specified timeout is reached. wait_for( callback: function () { // Your custom condition/callback logic here return true; // Change this based on your condition }, timeout: 10, quiet: false, intervalMs: 100, message: 'Waiting for something to happen...', ); [!NOTE] you can also return null if you want to abort the waiting process. The function will throw an exception if the callback returns null.","title":"The wait_for() function"},{"location":"going-further/wait-for/#the-wait_for_port-function","text":"The wait_for_port() method waits for a network port to be accessible. It checks if a connection can be established to the specified port on a given host within the specified timeout. The method allows customization by providing options such as the host. Example: wait_for_port( port: 8080, host: '127.0.0.1', timeout: 15, quiet: false, intervalMs: 500, message: 'Waiting for port localhost:8080 to be accessible...', );","title":"The wait_for_port() function"},{"location":"going-further/wait-for/#the-wait_for_url-function","text":"The wait_for_url() method waits for a URL to be accessible. It attempts to open a connection to the specified URL within the specified timeout. wait_for_url( url: 'https://example.com', timeout: 10, quiet: false, intervalMs: 200, message: 'Waiting for https://example.com to be accessible...', );","title":"The wait_for_url() function"},{"location":"going-further/wait-for/#the-wait_for_http_response-function","text":"The wait_for_http_response() function waits for a specified URL to return a response assessed using a user-defined $responseChecker callback function. It allows for a detailed validation of the response content. Example validating the status code and the response content: wait_for_http_response( url: 'https://example.com', responseChecker: function (ResponseInterface $response) { return $response->getStatusCode() !== 200 && u($response->getContent())->containsAny(['Example Domain']); }, timeout: 2, );","title":"The wait_for_http_response() function"},{"location":"going-further/wait-for/#the-wait_for_http_status-function","text":"The wait_for_http_status() function is a specialized version of wait_for_http_response() , specifically designed to monitor a URL until it returns a desired HTTP status code. Example: wait_for_http_status( url: 'https://example.com/api', status: 200, timeout: 10, quiet: false, intervalMs: 300, message: 'Waiting for https://example.com/api to return HTTP 200', );","title":"The wait_for_http_status() function"},{"location":"going-further/wait-for/#the-wait_for_docker_container-function","text":"The wait_for_docker_container() function waits for a Docker container to be ready. It checks if the container is running and if the specified port is accessible within the specified timeout. It can also wait for a specific check to be successful, by providing a $check callback function. Example: wait_for_docker_container( container: 'mysql-container', containerChecker: function ($containerId) { return run(\"docker exec $containerId mysql -uroot -proot -e 'SELECT 1'\", allowFailure: true)->isSuccessful(); }, portsToCheck: [3306] timeout: 30, quiet: false, intervalMs: 100, message: 'Waiting for my-container to be ready...', );","title":"The wait_for_docker_container() function"},{"location":"going-further/watch/","text":"Watching file changes Castor provides a watch() function that will watch a file or a directory and call a callback function when the file or directory changes: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { watch('src/', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); } $action can be either create , write , rename or remove and the file will be the absolute path to the file. Recursive watch By default the watch() function will not watch subdirectories. You can change that by passing a path suffixed by /... : use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src folder watch('src/...', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); } Stopping the watch The watch() function will look at the return value of the callback function. If the callback function returns false the watch will stop: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src folder watch('src/...', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; return false; }); echo 'stopped watching'; // will print \"stopped watching\" once a file has been modified in the src folder } Watching multiple paths The watch() function can watch multiple paths at the same time: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src and tests folders watch(['src/...', 'tests/...'], function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); }","title":"Watching file changes"},{"location":"going-further/watch/#watching-file-changes","text":"Castor provides a watch() function that will watch a file or a directory and call a callback function when the file or directory changes: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { watch('src/', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); } $action can be either create , write , rename or remove and the file will be the absolute path to the file.","title":"Watching file changes"},{"location":"going-further/watch/#recursive-watch","text":"By default the watch() function will not watch subdirectories. You can change that by passing a path suffixed by /... : use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src folder watch('src/...', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); }","title":"Recursive watch"},{"location":"going-further/watch/#stopping-the-watch","text":"The watch() function will look at the return value of the callback function. If the callback function returns false the watch will stop: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src folder watch('src/...', function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; return false; }); echo 'stopped watching'; // will print \"stopped watching\" once a file has been modified in the src folder }","title":"Stopping the watch"},{"location":"going-further/watch/#watching-multiple-paths","text":"The watch() function can watch multiple paths at the same time: use Castor\\Attribute\\AsTask; use function Castor\\watch; #[AsTask()] function watch(): void { // watch recursively inside the src and tests folders watch(['src/...', 'tests/...'], function (string $file, string $action) { echo \"File {$file} has been {$action}\\n\"; }); }","title":"Watching multiple paths"}]}